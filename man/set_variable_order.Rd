% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/set.R
\name{set_variable_order}
\alias{set_variable_order}
\title{Modify order of variables in a data dictionary}
\usage{
set_variable_order(dictionary, ..., .before = NULL, .after = NULL)
}
\arguments{
\item{dictionary}{A \link[=data_dictionary]{data dictionary} object}

\item{..., .before, .after}{see \link[dplyr:relocate]{relocate documentation}}
}
\description{
This is a thin wrapper for using \link[dplyr:relocate]{dplyr::relocate} to set the order
of variables in a A \link[=data_dictionary]{data dictionary} object. The inputs (apart from
\code{dictionary}) are named and interpreted exactly as they are in
\link[dplyr:relocate]{dplyr::relocate}. The variables will be reordered as specified in the
dictionary returned.
}
\details{
The order of variables in the dictionary determines the order of
results when indexing functions are applied, such as \link{index_terms}.
Setting the order of variables to match their expected order of
presentation in tables can help streamline table generation (see
examples.)
}
\examples{

dd_ordered <- as_data_dictionary(iris) \%>\%
  set_variable_order(Species, .before = Sepal.Length) \%>\%
  set_variable_order(ends_with("Length"), .after = Petal.Width)

set_default_dictionary(dd_ordered)

# index_terms() is using the order of variables in `dd_ordered` to
# return a dataframe sorted the same way as `dd_ordered` is. Note
# this also respects the ordering of categories within variables,
# which is not straightforward to do with the usual dplyr::arrange()

lm(Sepal.Length ~ ., data = iris) \%>\%
  broom::tidy() \%>\%
  dplyr::filter(term != "(Intercept)") \%>\%
  append_term_key() \%>\%
  index_terms()


}
