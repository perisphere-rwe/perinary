% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/translate.R
\name{translate_data}
\alias{translate_data}
\alias{translate_names}
\alias{translate_categories}
\title{Translate data, names, and categories with a dictionary}
\usage{
translate_data(
  x,
  ...,
  dictionary = NULL,
  units = "none",
  warn_unmatched = TRUE,
  apply_variable_labels = TRUE,
  apply_category_labels = TRUE,
  nominals_to_factor = TRUE,
  drop_unused_levels = FALSE
)

translate_names(
  x,
  ...,
  .list = NULL,
  dictionary = NULL,
  units = "none",
  to_factor = FALSE,
  warn_unmatched = TRUE,
  drop_unused_levels = FALSE
)

translate_categories(
  x,
  ...,
  .list = NULL,
  dictionary = NULL,
  names = NULL,
  to_factor = FALSE,
  warn_unmatched = TRUE,
  drop_unused_levels = FALSE
)
}
\arguments{
\item{x}{An object to translate.
\itemize{
\item For \code{translate_data()}: \code{x} must be a data frame.
\item For \code{translate_names()} and \code{translate_categories()}: \code{x} must be a
character/factor.
}}

\item{...}{Additional arguments passed to the \code{translate} method.
\itemize{
\item For \code{translate_data}, nothing happens at the moment. Eventually
this \code{...} will be used to select which columns to translate. The
default will be \code{everything()}.
\item For \code{translate_names}, \code{...} must contain name-value pairs. The name can
be any value in \code{x} and the corresponding value indicates what to
translate \code{x} to. This can be used  to overrule the value that the
dictionary would translate to, or to add extra translation maps in cases
where the dictionary doesn't contain a map for all values in \code{x}
(see examples).
}}

\item{dictionary}{A \link[=data_dictionary]{data dictionary} object. If \code{NULL}, uses the default dictionary set via \code{\link[=set_default_dictionary]{set_default_dictionary()}}.}

\item{units}{a character value indicating how units should be incorporated
into variable labels. Valid choices are
\itemize{
\item \code{"none"} : do not include units in labels, e.g., "Age"
\item \code{"descriptive"} : include labels, e.g., "Age, \emph{years}"
\item \code{"model"} : include label and model divisor, e.g., "Age, \emph{per 10 years}"
}

Note that setting \code{units = "model"} \strong{will modify values} of numeric
variables in \code{data} with a \code{divby_modeling} value. See details for explanation.}

\item{warn_unmatched}{a logical value. If \code{TRUE} (default), then
a warning is thrown whenever 1 or more variables in \code{data} do not
have supporting documentation in \code{dictionary}. If \code{FALSE}, then
this information will not be presented in a warning.}

\item{apply_variable_labels}{Logical (default \code{TRUE}). If \code{TRUE},
variable labels are attached as column attributes.}

\item{apply_category_labels}{Logical (default \code{TRUE}). If \code{TRUE},
category levels are replaced with labels. Output is also coerced to
a factor so that the order of categories from the dictionary is applied.}

\item{nominals_to_factor}{Logical (default \code{TRUE}). If \code{TRUE},
nominal variables are converted to factors with level order
determined using relevant information from \code{dictionary}.}

\item{drop_unused_levels}{Logical (default \code{FALSE}). If \code{TRUE} (and
\code{nominals_to_factor = TRUE} or \code{to_factor = TRUE}), unused levels will be
dropped from nominal variables.}

\item{.list}{For \code{translate_names()}: an optional \strong{named} character
vector mapping \code{old_name = "Label"}. When supplied, it takes precedence
over the dictionary lookup (useful for ad-hoc overrides).}

\item{to_factor}{Logical (default \code{TRUE}). If \code{TRUE},
output will be converted to a factor with its level order determined
using relevant information from \code{dictionary}.}

\item{names}{For \code{translate_categories()}: optional character vector of
variable names to translate (useful when \code{x} is a data frame or when
disambiguation is needed).}
}
\value{
\itemize{
\item \code{translate_data()}: returns a data frame with labels/levels updated.
Numeric columns may be scaled when \code{units = "model"}.
\item \code{translate_names()}: returns a factor with variable labels
corresponding to input names.
\item \code{translate_categories()}: returns a factor with category labels
corresponding to input levels.
}
}
\description{
The \verb{translate_*()} helpers look up metadata in a \code{dictionary} and
apply it to your data:
\itemize{
\item \code{translate_data()} attaches variable labels as column attributes,
optionally recodes category labels and enforces category order,
and optionally scales numeric variables for modeling.
\item \code{translate_names()} replaces variable names with variable labels.
\item \code{translate_categories()} replaces category levels with
category labels and enforces category order specified in \code{dictionary}.
}
}
\details{
Transfer variable labels/units and category labels/order into a vector
or data frame.

With the choice \code{units = "model"}, any numeric variable in
\code{dictionary} that has a \code{divby_modeling} value will be modified in the
data, specifically by being divided by \code{divby_modeling}. This transform
will also be indicated in the label for said variable. E.g., if a
variable \code{age} has label \code{"Age"}, a unit of \code{"years"} and \code{divby_modeling}
of 10, setting \code{units = "model"} will cause the \code{age} column to be divided
by 10 with a label of "Age, per 10 years"
}
\examples{

age_years <- numeric_variable(
  name = "age_years",
  label = "Age of participant",
  units = "years",
  divby_modeling = 10
)

gender <- nominal_variable(
  name = "gender",
  label = "Gender of participant",
  category_levels = c("M", "F"),
  category_labels = c("Male", "Female")
)

dd <- data_dictionary(age_years, gender)
dat <- data.frame(age_years = 55, gender = "M")

# Translate an entire data frame (labels + categories; descriptive units)
out1 <- translate_data(
  dat, dictionary = dd,
  units = "descriptive"
)
purrr::map(out1, ~ attr(.x, "label"))

# Prepare for modeling: scale numerics by divby_modeling and update labels
out2 <- translate_data(
  dat, dictionary = dd,
  units = "model"
)
out2$age_years # now 5.5 (i.e., 55 / 10)

attr(out2$age_years, "label") # "Age of participant, per 10 years"

# Replace variable names with labels (useful after pivot_longer)
translate_names(c("age_years", "gender"), dictionary = dd)

# Replace category codes with labels (and enforce order)
translate_categories(dat$gender, dictionary = dd)

}
\seealso{
\code{\link[=data_dictionary]{data_dictionary()}}, \code{\link[=as_data_dictionary]{as_data_dictionary()}}, \code{\link[=set_default_dictionary]{set_default_dictionary()}}
}
