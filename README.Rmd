---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# perinary

<!-- badges: start -->
[![R-CMD-check](https://github.com/bcjaeger/perinary/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/bcjaeger/perinary/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/bcjaeger/perinary/graph/badge.svg)](https://app.codecov.io/gh/bcjaeger/perinary)
<!-- badges: end -->

**Why make this?** Data dictionaries (referred to as "dictionaries" from here) are often developed outside of a computing session and stored as a static file. Dictionaries are helpful in large projects with many outputs, providing a central resource for consistent and accurate annotation of tables and figures. However, the process of making and using dictionaries is tedious, so `perinary` was developed to reduce friction. 

To make dictionaries, there are two primary classes of functions:

1. `get`: retrieve meta data from a dictionary
2. `set`: modify meta data in a dictionary

To use the dictionary, there are three classes of functions:

1. `translate`: modify names or category labels 
2. `append`: add rows and/or columns to a data frame
3. `index`: order the rows of a data frame

While `get/set` functions are applied to a dictionary, the `translate` and `append` functions are members of the `DataDictionary` class, meaning they are called from the dictionary object.

## Installation

You can install the development version of `perinary` from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("perisphere-rwe/perinary")
```

## Data dictionaries

Data dictionaries help organize meta data about variables, storing information relevant for tables and figures that is not easily stored in data frames. A data dictionary is most useful in complex projects with many variables and/or many expected outputs, particularly when consistency between outputs is a goal. 

There are two ways to initialize a dictionary. You can build them using `NumericVariable` and `NominalVariable` objects (not shown here, see vignette), but this can be tedious if you have a lot of variables. For most cases, you'll want to use the `as_data_dictionary()` to create a starter dictionary from a given dataset.

```{r, message=FALSE}

library(perinary)
library(tidyverse)
library(palmerpenguins)

data_peng <- penguins %>% 
  select(species, sex, body_mass_g, bill_length_mm, bill_depth_mm)

dd_peng <- as_data_dictionary(data_peng)

dd_peng

```

## Retrieve meta data with `get`

Let's be honest, dictionaries are annoying to write. `perinary` aims to make it less annoying with `get_unknowns()`. This function tells us what relevant information is missing from a `dictionary`. If you set `as_request = TRUE`, a bullet point list is returned in the R console. This text is intended to help start a discussion about filling in the gaps.

```{r}
get_unknowns(dd_peng, as_request = TRUE)
```

If you want to get straight to filling in unknowns, specify `as_code = TRUE`:

```{r}
get_unknowns(dd_peng, as_code = TRUE)
```

Other `get` functions include 

- `get_term_key()`: returns a `tibble` that links nominal variable categories to modeling terms. This is helpful when you want to incorporate meta information into standard output from modeling functions.

  ```{r}
  get_term_key(dd_peng)
  ```

- `get_dictionary()`: returns a `tibble` containing raw dictionary meta data. This is helpful when you want to apply meta data in a non-standard way.

  ```{r}
  get_dictionary(dd_peng)
  ```

- general `get` functions that are exported from the `DataDictionary` class

## Modify dictionaries with `set`

`perinary`'s family of `set` functions provide the interface to modify a dictionary's meta data.

```{r}

dd_peng <- dd_peng %>% 
  set_labels(species = "Species",
             sex = "Sex",
             body_mass_g = "Body mass",
             bill_length_mm = "Bill length",
             bill_depth_mm = "Bill depth") %>% 
  set_units(bill_length_mm = "mm",
            bill_depth_mm = "mm",
            body_mass_g = "grams") %>% 
  set_divby_modeling(bill_length_mm = 5,
                     bill_depth_mm = 5)

```

### Identifier variables

An identifier variable uniquely defines sampling units in a data set. An identifier variable can cause disruption in a data dictionary if it is treated like a factor. For example, we don't want to supply labels for each level of an identifier, and we don't want to summarize data for each level of an identifier. To demonstrate the problem identifiers can pose, here's what would have happened in our call to `get_unknowns()` if we had an unmanaged identifier variable in the dictionary.

```{r}

data_peng %>% 
  mutate(penguid_id = as.character(seq(n()))) %>% 
  as_data_dictionary() %>% 
  get_unknowns(as_request = TRUE)

```

The issue is that we don't want or need to supply category labels for `penguin_id`, so it isn't helpful for these to be included in our list of unknowns. The fix is to designate `penguin_id` (or generally any identifier variables) as an identifier variable, which should take care of all potential downstream issues.

```{r}

data_peng %>% 
  mutate(penguin_id = as.character(seq(n()))) %>% 
  as_data_dictionary() %>% 
  set_identifiers(penguin_id) %>% 
  get_unknowns(as_request = TRUE)

```

### Nominal variables

Modify the category labels for nominal variables with `set_category_labels()`:

```{r}

dd_peng <- dd_peng %>% 
  set_category_labels(sex = c(female = "Female penguins", 
                              male = "Male penguins"))

dd_peng

```

Modify category order for nominal variables with `set_category_order()`:

```{r}

# moves the specified category or categories to the front, putting the 
# remaining categories behind with the same relative order to each other

dd_peng <- dd_peng %>% 
  set_category_order(sex = c("male"),
                     species = c("Chinstrap"))

dd_peng

```



## Modify objects using dictionaries

The `translate` function family includes `translate_categories()`, `translate_names()`, and `translate_data()`. These functions are the bridge between your `dictionary` and your data. So, how do they work?

- Instead of requiring name-value pairs in the function call, `translate` functions look up the relevant name value pairs in `dictionary`:

  ```{r}
  data_peng %>% 
    mutate(sex = translate_categories(sex, dictionary = dd_peng))
  ```

- While `translate_categories()` replaces category levels with labels, `translate_names()` replaces variable names with labels. This is useful when variable names become column values, e.g., after using `pivot_longer` or `melt`:

  ```{r}
  
  data_peng %>% 
    pivot_longer(starts_with("bill_")) %>% 
    mutate(name = translate_names(name, dictionary = dd_peng))
  
  ```

- `translate_data()` is a general convenience tool that:

    + sets variable labels as column attributes
    
    + recodes category levels to corresponding labels 
    
    + converts characters to factors (factors are required to apply the category order specified in the dictionary)
    
    + divide continuous variables by their corresponding modeling divisor if `units = 'model', and update labels accordingly

  ```{r}
  data_peng %>% 
    translate_data(dictionary = dd_peng)
  ```

## Set your default

Writing meta data in a `dictionary` *should* make it easier to put that information in outputs. However, supplying the `dictionary` as an input to every single `perinary` function gets unnecessarily tedious. For convenience, you can save any `dictionary` you make as the "default" dictionary for `perinary` functions during your current R session. The default dictionary will be used whenever a `perinary` function is called and a `dictionary` is not explicitly supplied by the user.

```{r}

set_default_dictionary(dd_peng)

data_peng %>% 
  pivot_longer(starts_with("bill_")) %>% 
  mutate(name = translate_names(name),
         sex = translate_categories(sex))

```

**Note:** for the remainder of the `ReadMe`, we *could* omit `dictionary = dd_peng` in all `perinary` functions because we have set that as our default. However, we do not take this semantic shortcut because it may be confusing for readers who skip sections or who copy/paste example code.

## Model output and dictionaries

If you are using a package like `gtsummary`, which incorporates variable labels automatically, `translate()` is probably all you need from `perinary`. In the example below, we translate our data with `units` set to `"model"`, which additionally preps continuous variables by dividing them by their modeling unit and (e.g., bill length is modeled per 10 mm) and updates labels accordingly. 

```{r, eval = FALSE}

library(gtsummary)

data_peng %>% 
  translate_data(units = 'model', dictionary = dd_peng) %>% 
  lm(formula = body_mass_g ~ sex + species + bill_length_mm + bill_depth_mm, 
     data = .) %>% 
  tbl_regression()

```

```{r}
knitr::include_graphics('img/screen-regression_table.png')
```

In rare cases, `gtsummary` may not provide tools to tabulate our regression results. In those cases, we can use functions from the `append` and `index` class.

Let's start with tidied model output from `broom`:

```{r}

library(broom)

fit <- data_peng %>% 
  translate_data(units = 'model', dictionary = dd_peng) %>% 
  lm(formula = body_mass_g ~ sex + species + bill_length_mm + bill_depth_mm, 
     data = .) %>% 
  tidy(conf.int = TRUE)

fit

```

We use `append_term_key()` to add columns indicating variable name, category level, category label, and reference groups to the model output (a row is also added for each reference group).

```{r}

fit_appended <- append_term_key(fit, dictionary = dd_peng)

fit_appended

```

Second, we use `index_terms` to re-order the rows of these data based on the order they appear in the dictionary. This is helpful when you want variables to be listed in consistent order throughout your report.

```{r}

fit_sorted <- index_terms(fit_appended, dictionary = dd_peng)

```

Third, we tabulate the results

```{r}

library(gt)
library(table.glue)

data_gt <- fit_sorted %>% 
  filter(name != "(Intercept)") %>% 
  # push labels for continuous bill variables into the label column
  mutate(
    label = coalesce(label, 
                     translate_names(name, units = 'model', 
                                     dictionary = dd_peng)
    )
  ) %>% 
  # Add a custom group for the bill variables
  add_count(name) %>% 
  mutate(name = if_else(n==1, 
                        "Bill dimensions", 
                        translate_names(name))) %>% 
  # drop unused columns and make final modifications
  transmute(
    name, 
    label,
    # format results with table.glue
    estimate = if_else(
      reference, 
      true = "0 (reference)", 
      false = table_glue("{estimate} ({conf.low}, {conf.high})")),
    p.value = table_pvalue(p.value)
  )

gt(data_gt, groupname_col = 'name', rowname_col = 'label') %>% 
  tab_style(
    style = cell_text(indent = px(16)),           
    locations = cells_stub()
  ) %>% 
  cols_align('center', columns = c(estimate, p.value)) %>% 
  cols_label(estimate = md("Estimated body mass<br/>difference, grams (95% CI)"), 
             p.value = "P-value") %>% 
  tab_stubhead(label = md("**Characteristic**")) %>% 
  tab_options(table.width = pct(80))
```



